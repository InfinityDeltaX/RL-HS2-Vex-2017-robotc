#pragma config(Sensor, dgtl1,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  led3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  ,               sensorQuadEncoder)
#pragma config(Motor,  port1,           flashlight,    tmotorNone, openLoop)
#pragma config(Motor,  port2,           drivemotor1,   tmotorServoContinuousRotation, openLoop, encoderPort, None)
#pragma config(Motor,  port3,           drivemotor2,   tmotorServoContinuousRotation, openLoop, encoderPort, None)
#pragma config(Motor,  port4,           drivemotor3,   tmotorServoContinuousRotation, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           drivemotor4,   tmotorServoContinuousRotation, openLoop, encoderPort, dgtl5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void movementControl();
void moveRelative(int forwardsbackwardsPower, int sidewaysPower, int rotationPower);
void driveSet(int aPower, int bPower, int cPower, int dPower);
void moveAbsolute(int fieldX, int fieldY, float targetfieldAngle, int speed);
float computeAngleFromR(int r);
void movePolarRelative(float angle, int speed);
void addConcurrentYawAnglePerSecond(float angle);
void addConcurrentYaw(int power);
void resetAllIMEs();
void functionControl();
void alternateBlinkers();

int currentPositionX = 0;
int currentPositionY = 0;
int currentPositionR = 0;

int encoderTicksPerTurn = 300;
int wheelTurnsPerRobotTurn = 3;
bool ledflashconfig = 0;

task main()
{
	//motor[drivemotor2] = 64;
	while(true) {
		movementControl();
		functionControl();
	}

}

void functionControl(){
	if(vexRT[Btn7D] == 1) {moveAbsolute(0, 7000, 0.5, 60);}
	if(vexRT[Btn7R] == 1) {alternateBlinkers();}
}

void movementControl(){
	int rotationPower = vexRT[Ch4];
	int forwardsbackwardsPower = -1 * vexRT[Ch2];
	int sidewaysPower = -1 * vexRT[Ch1];

	moveRelative(forwardsbackwardsPower, sidewaysPower, rotationPower);
}

void moveRelative(int forwardsbackwardsPower, int sidewaysPower, int rotationPower){
	int a = -1 * forwardsbackwardsPower + -1 * sidewaysPower + rotationPower;
	int b = forwardsbackwardsPower + -1 * sidewaysPower + rotationPower;
	int c = forwardsbackwardsPower + sidewaysPower + rotationPower;
	int d = -1 * forwardsbackwardsPower + sidewaysPower + rotationPower;

	driveSet(a/2, b/2, c/2, d/2);
}

void driveSet(int aPower, int bPower, int cPower, int dPower){
	motor[drivemotor1] = aPower;
	motor[drivemotor2] = bPower;
	motor[drivemotor3] = cPower;
	motor[drivemotor4] = dPower;

	//motor1Power = aPower;
	//motor2Power = bPower;
	//motor3Power = cPower;
	//motor4Power = dPower;

	//trackPosition();
}

void alternateBlinkers(){
	ledflashconfig = !ledflashconfig;
	SensorValue[led2] = ledflashconfig;
	SensorValue[led3] = !ledflashconfig;
}

void moveAbsolute(int fieldX, int fieldY, float targetfieldAngle, int speed){
	int xdelta = fieldX - currentPositionX;
	int ydelta = fieldY - currentPositionY;
	if(xdelta==0) {xdelta = 1;}
	int movementAngle = atan(ydelta/ (float) xdelta);
	//int rdelta = fieldR - currentPositionR;

	int distance = sqrt(xdelta*xdelta + ydelta*ydelta);
	int steps = 10;


	float startRAngle = computeAngleFromR(currentPositionR);
	float endRAngle = targetfieldAngle-startRAngle;
	float currentRAngle = 0;

	float turnByAngle = endRAngle/steps;

	int delayTime = distance/speed/steps*100;
	float yawAnglePerSecond = turnByAngle/delayTime*100;

	for(int i = 0; i < steps; i++){
		//movementAngle
		alternateBlinkers();
		movePolarRelative(movementAngle-currentRAngle, speed);
		addConcurrentYawAnglePerSecond(yawAnglePerSecond);
		delay(delayTime);
		currentRAngle += turnByAngle;
	}

	//int //in the same amount of time we need to complete rdelta turns.
}

void movePolarRelative(float angle, int speed){
	moveRelative(sin(angle) * speed, cos(angle) * speed, 0);
}

float computeAngleFromR(int r){
	return ( r/ ((float) encoderTicksPerTurn * wheelTurnsPerRobotTurn));
	//return 0.0;
}

void trackPosition(){ //add all the movement since the last time this function was run. Therefore, we should try to run it every time the robot turns.
	int a = nMotorEncoder[drivemotor1];
	int b = nMotorEncoder[drivemotor2];
	int c = nMotorEncoder[drivemotor3];
	int d = nMotorEncoder[drivemotor4];

	resetAllIMEs();

	int rDist = (a + b + c + d)/4;
	int fwbDist = ( (b-rDist) + (c-rDist) ) /2 + -1 * ( (a-rDist) + (d-rDist) ) /2;
	int sideDist = ( (c-rDist) + (d-rDist) ) /2 + -1 * ( (a-rDist) + (b-rDist) ) /2;
	float angle = computeAngleFromR(rDist);
	int xDist = sin(angle) * sideDist + cos(angle) * fwbDist;
	int yDist = cos(angle) * fwbDist + sin(angle) * sideDist;

	currentPositionX += xDist;
	currentPositionY += yDist;
	currentPositionR += rDist;
}

/*
void yawRelative(float targetRotation, int speed){
	speed = abs(speed);
	if(targetRotation < 0) speed = speed * -1;

	yawSet(speed);
	int rotationSoFar = currentPositionR;

	while(true){ //TODO
		trackPosition();
		delay(5);
		imeGet(0, &rotationSoFar);
	}
	stopAll();
}
*/

void resetAllIMEs(){
	nMotorEncoder[drivemotor1] = 0;
	nMotorEncoder[drivemotor2] = 0;
	nMotorEncoder[drivemotor3] = 0;
	nMotorEncoder[drivemotor4] = 0;
}

void addConcurrentYawAnglePerSecond(float angle){
  int power = (float) angle*400.0;
  addConcurrentYaw(power);
}

void addConcurrentYaw(int power){
  driveSet(motor[drivemotor1] + power, motor[drivemotor2] + power, motor[drivemotor3] + power, motor[drivemotor4] + power);
}
